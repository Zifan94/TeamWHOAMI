<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2360 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2360.xml">
<!ENTITY RFC2629 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC5226 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="yes" ?>

<?rfc toc="yes"?>

<?rfc tocdepth="4"?>

<?rfc symrefs="yes"?>

<?rfc sortrefs="yes" ?>

<?rfc compact="yes" ?>

<?rfc subcompact="no" ?>

<rfc category="std" docName="rfc1" ipr="playgroundStd_v1_0" number="1">


  <front>
    <title abbrev="Lab2PRFC">Lab 2 Playground Request For Comments</title>
    <author fullname="Evan Hsia" initials="E.H." role="editor" surname="Hsia">
      <organization>JHU Network Security Fall 2017</organization>
      <address>
        <postal>
          <street>Johns Hopkins University 122 Malone Hall/3400 North Charles St.</street>
          <city>Baltimore</city>
          <region>MD</region>
          <code>21218</code>
          <country>USA</country>
        </postal>
        <phone>+1 860-519-4112</phone>
        <email>ehsia1@jhu.edu</email>
      </address>
    </author>
    <date year="2017" month="October"/>
    <area>General</area>
    <workgroup>WHOAMI</workgroup>
    <keyword>PRFC</keyword>
    <abstract>
      <t>PEEP (Players Enjoy Eavesdropping Protocol) is a “middleware” protocol intended to provide reliable transmission
      between two communicating applications. The protocol is composed of three process: three-way handshake, data
      transmission and four-way termination. This document describes the functions to be performed by the PEEP layer
      and the program that implements it.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The purpose of lab 2 is to design and implement a TCP-like transport layer to be used by application-layer protocols.
      This layer connects to the Passthrough layer with the PLAYGROUND framework, designed by Dr. Seth James Nielson, to give students
      an environment to learn about internet security attacks and defenses on a much smaller scale. The application layer is the higher
      layer above the Passthrough.</t>

      <t>In particular, the transport layer in lab 2, dubbed PEEP (Players Enjoy Eavesdropping Protocol) consists of the
      following parts: a 3-way handshake to establish connection between a server side application and a client side
      application, data transmission between protocols, and a 4-way termination. Although there were multiple teams each working
      on an implementation on such a layer, the class as a whole was required to use the same general design so that every layer
      would operate on the same PLAYGROUND framework. To accomplish this, each team elected one member to participate in a PETF
      (Playground Engineering Task Force) to formulate a communal design for the layer, including the expectations of the 3-way
      handshake, data transmission, and 4-way termination, along with clear acceptance criteria of a PEEP packet and a state machine
      for the protocols. This PRFC will go into more depth of each of these aspects that the PETF agreed on as well as error handling.</t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119">RFC 2119</xref>.</t>
      </section>
    </section>
    <section title="Session Life">
      <t>Just like in TCP, the layer MUST create a sessions in order to account for multiple client protocols connecting to the same
      server protocol, and to account for the server protocol not terminating properly when a client finishes sending information.
      Even if different ports are used, the old protocol will still exist in memory. So we create a session to connect the client and
      server protocols, and in each session there MUST be session establishment and session termination. Both session establishment
      and termination MUST require client and server protocols sending different types of PEEP packets back and forth. Each of
      these packets will be discussed in further detail later in this document.</t>
      <section title="Session Establishment">
        <t>Session establishment MUST use a 3-way handshake involving three different types of PEEP packets. The client first sends
        a SYN packet to the server that the server validates, then the server replies with a SYN-ACK packet back to the client. Finally,
        the client sends an ACK packet to start the connection with the server.</t>

        <t>The 3-way handshake is designed for several reasons, and each step has a specific purpose to fulfill those reasons.</t>

        <t>The first step, when the client sends the initial SYN packet to the server, occurs because the client always requests
        data from the server first. This step is designed to account for the possibility of many clients requesting information
        from the server at the same time. This reason is why a SYN packet is used, as each SYN packet carries a random number, "seq", identifier.</t>

        <t>The next step occurs when the server sends a SYN-ACK packet back to the client. The server validates the client as a unique client,
        and then the server grants the connection. Here, each SYN-ACK packet carries a different "seq" random number, and also carries an "ack"
        integer, where "ack" MUST equal the "seq" from the client plus 1.</t>

        <t>In the final step, the client responds with just an ACK packet with both a "seq" and an "ack", sending a confirmation message
        to the server. The "seq" integer here is the same as the one from the SYN-ACK packet received from the server, and the "ack" integer
        is equal to the "ack" from the SYN-ACK packet plus 1. Upon the server receiving this packet, the layer would call the higher layer's,
        the PassThrough layer's, connection_made() function, and data transmission can commence.</t>
      </section>
      <section title="Session Termination">
        <t>Session termination, on the other hand, MUST consist of a 4-way termination. After sending all the data packets,
        the client sends a RIP packet to the server, followed by the server replying with a RIP-ACK packet. At this time, the server
        also MUST send any remaining data packets to the client, initiating and completing all final data transmission. After the server
        replies with the rest of the packets, the server then sends a RIP packet of its own to the client, and the client replies with
        a RIP-ACK packet to close the session.</t>

        <t>Each step of the termination can be broken down further. The first phase is when the client sends the RIP packet to the server.
        It is the product of the client finishing sending all of its data, and it communicating to the server that the connection can close.</t>

        <t>The next step, when the server sends the RIP-ACK packet back to the client, communicates to the client that the server has
        received that message that client protocol has finished. In order to complete the connection on the server side, however, the server
        MUST deliver to the client the rest of the data that the client has requested. Once the server has received the corresponding ACK packets
        from the client that confirm that the client received the data, the termination can proceed to the next step.</t>

        <t>The third step in the termination occurs when the server sends a RIP packet to the client. Just like with the client sending a RIP packet,
        the server is simply sending a message to the client communicating that it has finished sending data back and can close now.</t>

        <t>The last step, the client replying with a RIP-ACK, serves as confirmation from the client that it has received the message
        that the server can close. As a result, both protocols close, and the session terminates.</t>
      </section>
    </section>
    <section title="Packet Description">
      <t>In the previous section, the use of PEEP packets was brought up, but with little depth. In this section, we will more clearly
      describe the packet used in the PEEP layer.</t>
      <section title="PEEP Packet">
        <t>The PEEP packet is a general packet class designed to send the messages between the server and client. This does not
        include sending the actual data and information back and forth from server and client, as depending on the requests, the data
        will change. Rather, the PEEP packet is made for consistency so that the server and client know when to send information back
        and forth, and when to establish a connection or when to terminate one.</t>

        <t>The PEEP packet is a descendent of the PacketType class from Playground, and as such the fields inherit the types that Playground
        defines: UINT, INT, STRING, BOOL, BUFFER, and ComplexFieldType. Here, BUFFER and variations of UINT, were used in the field types.</t>

        <t>To be considered a PEEP packet, the packet MUST have five fields: "Type" of type UINT8, optional field "SequenceNumber" of UINT32
        (often abbreviated seq), "Checksum" of type UINT16, optional field "Acknowledgement" of type UINT32, and optional field "Data"
        of type BUFFER. All UINTS are unsigned integers, and BUFFER allows the data to be transmitted in bytes to the packets in order.</t>

        <t>The first field deals with the type of the packet. There are six types to any valid PEEP packet. There are SYN, SYN-ACK, ACK, RIP, RIP-ACK,
        and DATA. Depending on the packet type, the rest of the fields will differ in value to distinguish.</t>

        <section title="SYN Packet">
          <t>As mentioned previously, a SYN packet is used to</t>
        </section>

        <section title="SYN-ACK Packet">
        </section>

        <section title="ACK Packet">
        </section>

        <section title="RIP Packet">
        </section>

        <section title="RIP-ACK Packet">
        </section>

        <section title="DATA Packet">
        </section>
      </section>
    </section>
    <section title="Protocol Specification">
      <t>Just like in any other network interactions, there MUST be a client protocol and a server protocol. This section will
      describe the state machine of the client protocol, the state machine of the server protocol, and the data transmission between
      the two.</t>
      <section title="Client Machine">
        <t>At state 0, the client is in the Initial SYN State. In this state, the client prepares the checksum for the packet header fields.
        The client then sends the resulting SYN packet to the server to initiate connection.</t>

        <t>In state 1, the client is in the SYN-ACK State. This state exists when the client is awaiting the SYN-ACK packet response from the
        server. The client MUST have a timeout here to handle the case of the server taking too long to generate a response, which would result
        from either the initial SYN packet being invalid or the server crashing. If a packet is not received after the timeout, the program
        terminates. If the packet is received compute the checksum. If the checksum is incorrect, ignore the packet. Otherwise, proceed to
        transmission.</t>

        <t>In the Transmission State, state 2, the client can now send data packets. When packets are received in this state, the client replies
        to the server with ACK packets. While the client is in this state, if it receives a data packet from the server and the checksum is incorrect,
        the client can send back ACK packets alerting the server to retransmit the packet. Otherwise, the ACK packet sends a message of verification that
        it was received.</t>

        <t>In state 3, the RIP Sent State, the client sends a RIP packet to alert the server that it has sent all data and can close.</t>

        <t>In state 4, RIP_ACK Receive State, the client receives the RIP-ACK packet from the server and waits for the server to clear
        the buffer. Once the client receives the RIP packet from the server, the client proceeds to the Close State.</t>

        <t>In state 5, the client is in the Close State, and the client replies to the server with a RIP-ACK packet to send confirmation
        that it received the RIP packet.</t>

        <t>The client also has an Error State, in which it enters when any errors occur in any other state. The client either communicates
        to the server to retransmit, or it terminates the connection.</t>
      </section>
      <section title="Server Machine">
        <t>At state 0, the server is in the SYN-ACK State, where it awaits the SYN packet from the client protocol. When the SYN packet
        is received, the server computes its checksum and if it is correct, it sends the SYN-ACK packet back to the client. In this state,
        the server MUST have a timeout such that if the server does not receive the SYN packet within that timeout period, the program ends and
        the server clears its buffer.</t>

        <t>In state 1, the server is now in the SYN state. In this state, the server awaits the ACK packet from the client. Again, the server
        MUST have a timeout implemented here so that after a certain time, if the packet is not received, the handshake ends and the buffer is
        cleared. If the packet is received, and the checksum is correct, the server moves to transmission.</t>

        <t>In the Transmission State, state 2, the server can now send data packets to the client, sending ACK packets back to the client when
        packets are received. If the checksum of any received packet is incorrect, the server can alert the client in the ACK packet to retransmit,
        but otherwise the ACK packet replies with confirmation.</t>

        <t>In state 3, the Clear Buffer State, the server receives the RIP packet from the client and replies to the client with a RIP-ACK packet for
        confirmation. Then the server proceeds to clear the buffer. It sends any leftover data to the client, receiving ACK packets from the client for
        confirmation.</t>

        <t>In state 4, the RIP Sent State, the server sends a RIP packet to the client after it finishes clearing the buffer. This packet lets
        the client know that the server has finished clearing the buffer and is ready to close.</t>

        <t>In state 5, the server is in the Close State, and the server receives the RIP-ACK packet from the client, letting it know that
        both protocols can close.</t>

        <t>The server also has an Error State, in which it enters when any errors occur in any other state. The server either communicates
        to the client to retransmit, or it terminates the connection.</t>
      </section>
      <section title="Data Transmission">
        <t>While both the client and server are in their Transmission States, both can send and receive data packets.</t>

        <t>The process for receiving data packets is designed as follows. Each protocol MUST receive the data packet bytes
        and, after the last packet is received, reply with an ACK packet for confirmation. This way, the ACK also guarantees that the packets
        are received in order, and all the packets are received. The receiving protocol must also validate the packets by computing and verifying
        their Checksums. The process for computing Checksum will be discussed in further detail in a later section.</t>

        <t>The process for sending data packets is different. Both the client and server MUST have a “window” to control data packets. What does this mean?
        Assume the window size is 5. Then the client/server could send 5 data packets without receiving ACK packets. And then even if they
        have more data packets, they will have to wait for ACK packets. If they receive ACK packets for some of the data packets, the window could move forward.
        But if they don’t receive any ACK packets within a timeout, they MUST send those packets again.</t>

        <t>While these processes are defined separately, obviously both will be interacting with each other concurrently. When one protocol sends data,
        the other is receiving it, so both the client and server MUST work together during data transmission.</t>
        <section title="Computational Algorithms">
          <t>Up to this point, Checksum has been discussed a lot but not in depth. This section will break down Checksum in more detail.</t>

          <t></t>
        </section>
      </section>
      <section title="Error Handling">
        <t>For a successful PEEP layer, there MUST exist two types of error handling in both the client and server whenever packets are received. The
        first type is a timeout whenever either protocol is awaiting a response, and the second is the checksum to ensure the right packets are
        received.</t>

        <t>Both sides MUST have a timeout whenever a response is expected for multiple reasons. The first is if there is an error on the other end.
        So if the client is waiting for a server response, and the server crashes or takes too long because it encounters issues with creating the
        new packets to send, then the client can terminate the connection because the response is taking too long. Another reason is if there
        is something blocking the packet in another layer. At that point, the packet would never arrive to the client, and so the connection
        would be terminated after timeout.</t>

        <t>Both sides MUST also validate the Checksum of each packet to ensure it is the right packet that the protocol is receiving. The packet
        could either have been generated incorrectly by the other side or could have been altered in another layer. So the Checksum is used to
        match the fields of the PEEP packet to ensure that it is the one that the protocol was expecting. If the Checksum is incorrect, the protocol
        asks for a retransmission of the packet.</t>
      </section>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &RFC2119;
    </references>
  </back>
</rfc>
